{"remainingRequest":"/Users/huangrong/workspace/apitest/apitest-web/node_modules/babel-loader/lib/index.js!/Users/huangrong/workspace/apitest/apitest-web/src/store/modules/permission.js","dependencies":[{"path":"/Users/huangrong/workspace/apitest/apitest-web/src/store/modules/permission.js","mtime":1590380748863},{"path":"/Users/huangrong/workspace/apitest/apitest-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/huangrong/workspace/apitest/apitest-web/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _objectSpread from \"/Users/huangrong/workspace/apitest/apitest-web/node_modules/@babel/runtime-corejs2/helpers/esm/objectSpread2\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport { asyncRoutes, constantRoutes } from '@/router';\n/**\n * Use meta.role to determine if the current user has permission\n * @param roles\n * @param route\n */\n\nfunction hasPermission(roles, route) {\n  if (route.meta && route.meta.roles) {\n    return roles.some(function (role) {\n      return route.meta.roles.includes(role);\n    });\n  } else {\n    return true;\n  }\n}\n/**\n * Filter asynchronous routing tables by recursion\n * @param routes asyncRoutes\n * @param roles\n */\n\n\nexport function filterAsyncRoutes(routes, roles) {\n  var res = [];\n  routes.forEach(function (route) {\n    var tmp = _objectSpread({}, route);\n\n    if (hasPermission(roles, tmp)) {\n      if (tmp.children) {\n        tmp.children = filterAsyncRoutes(tmp.children, roles);\n      }\n\n      res.push(tmp);\n    }\n  });\n  return res;\n}\nvar state = {\n  routes: [],\n  addRoutes: []\n};\nvar mutations = {\n  SET_ROUTES: function SET_ROUTES(state, routes) {\n    state.addRoutes = routes;\n    state.routes = constantRoutes.concat(routes);\n  }\n};\nvar actions = {\n  generateRoutes: function generateRoutes(_ref, roles) {\n    var commit = _ref.commit;\n    return new Promise(function (resolve) {\n      var accessedRoutes;\n\n      if (roles.includes('admin')) {\n        accessedRoutes = asyncRoutes || [];\n      } else {\n        accessedRoutes = filterAsyncRoutes(asyncRoutes, roles);\n      }\n\n      commit('SET_ROUTES', accessedRoutes);\n      resolve(accessedRoutes);\n    });\n  }\n};\nexport default {\n  namespaced: true,\n  state: state,\n  mutations: mutations,\n  actions: actions\n};",{"version":3,"sources":["/Users/huangrong/workspace/apitest/apitest-web/src/store/modules/permission.js"],"names":["asyncRoutes","constantRoutes","hasPermission","roles","route","meta","some","role","includes","filterAsyncRoutes","routes","res","forEach","tmp","children","push","state","addRoutes","mutations","SET_ROUTES","concat","actions","generateRoutes","commit","Promise","resolve","accessedRoutes","namespaced"],"mappings":";;;;AAAA,SAASA,WAAT,EAAsBC,cAAtB,QAA4C,UAA5C;AAEA;;;;;;AAKA,SAASC,aAAT,CAAuBC,KAAvB,EAA8BC,KAA9B,EAAqC;AACnC,MAAIA,KAAK,CAACC,IAAN,IAAcD,KAAK,CAACC,IAAN,CAAWF,KAA7B,EAAoC;AAClC,WAAOA,KAAK,CAACG,IAAN,CAAW,UAAAC,IAAI;AAAA,aAAIH,KAAK,CAACC,IAAN,CAAWF,KAAX,CAAiBK,QAAjB,CAA0BD,IAA1B,CAAJ;AAAA,KAAf,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAP;AACD;AACF;AAED;;;;;;;AAKA,OAAO,SAASE,iBAAT,CAA2BC,MAA3B,EAAmCP,KAAnC,EAA0C;AAC/C,MAAMQ,GAAG,GAAG,EAAZ;AAEAD,EAAAA,MAAM,CAACE,OAAP,CAAe,UAAAR,KAAK,EAAI;AACtB,QAAMS,GAAG,qBAAQT,KAAR,CAAT;;AACA,QAAIF,aAAa,CAACC,KAAD,EAAQU,GAAR,CAAjB,EAA+B;AAC7B,UAAIA,GAAG,CAACC,QAAR,EAAkB;AAChBD,QAAAA,GAAG,CAACC,QAAJ,GAAeL,iBAAiB,CAACI,GAAG,CAACC,QAAL,EAAeX,KAAf,CAAhC;AACD;;AACDQ,MAAAA,GAAG,CAACI,IAAJ,CAASF,GAAT;AACD;AACF,GARD;AAUA,SAAOF,GAAP;AACD;AAED,IAAMK,KAAK,GAAG;AACZN,EAAAA,MAAM,EAAE,EADI;AAEZO,EAAAA,SAAS,EAAE;AAFC,CAAd;AAKA,IAAMC,SAAS,GAAG;AAChBC,EAAAA,UAAU,EAAE,oBAACH,KAAD,EAAQN,MAAR,EAAmB;AAC7BM,IAAAA,KAAK,CAACC,SAAN,GAAkBP,MAAlB;AACAM,IAAAA,KAAK,CAACN,MAAN,GAAeT,cAAc,CAACmB,MAAf,CAAsBV,MAAtB,CAAf;AACD;AAJe,CAAlB;AAOA,IAAMW,OAAO,GAAG;AACdC,EAAAA,cADc,gCACanB,KADb,EACoB;AAAA,QAAjBoB,MAAiB,QAAjBA,MAAiB;AAChC,WAAO,IAAIC,OAAJ,CAAY,UAAAC,OAAO,EAAI;AAC5B,UAAIC,cAAJ;;AACA,UAAIvB,KAAK,CAACK,QAAN,CAAe,OAAf,CAAJ,EAA6B;AAC3BkB,QAAAA,cAAc,GAAG1B,WAAW,IAAI,EAAhC;AACD,OAFD,MAEO;AACL0B,QAAAA,cAAc,GAAGjB,iBAAiB,CAACT,WAAD,EAAcG,KAAd,CAAlC;AACD;;AACDoB,MAAAA,MAAM,CAAC,YAAD,EAAeG,cAAf,CAAN;AACAD,MAAAA,OAAO,CAACC,cAAD,CAAP;AACD,KATM,CAAP;AAUD;AAZa,CAAhB;AAeA,eAAe;AACbC,EAAAA,UAAU,EAAE,IADC;AAEbX,EAAAA,KAAK,EAALA,KAFa;AAGbE,EAAAA,SAAS,EAATA,SAHa;AAIbG,EAAAA,OAAO,EAAPA;AAJa,CAAf","sourcesContent":["import { asyncRoutes, constantRoutes } from '@/router'\n\n/**\n * Use meta.role to determine if the current user has permission\n * @param roles\n * @param route\n */\nfunction hasPermission(roles, route) {\n  if (route.meta && route.meta.roles) {\n    return roles.some(role => route.meta.roles.includes(role))\n  } else {\n    return true\n  }\n}\n\n/**\n * Filter asynchronous routing tables by recursion\n * @param routes asyncRoutes\n * @param roles\n */\nexport function filterAsyncRoutes(routes, roles) {\n  const res = []\n\n  routes.forEach(route => {\n    const tmp = { ...route }\n    if (hasPermission(roles, tmp)) {\n      if (tmp.children) {\n        tmp.children = filterAsyncRoutes(tmp.children, roles)\n      }\n      res.push(tmp)\n    }\n  })\n\n  return res\n}\n\nconst state = {\n  routes: [],\n  addRoutes: []\n}\n\nconst mutations = {\n  SET_ROUTES: (state, routes) => {\n    state.addRoutes = routes\n    state.routes = constantRoutes.concat(routes)\n  }\n}\n\nconst actions = {\n  generateRoutes({ commit }, roles) {\n    return new Promise(resolve => {\n      let accessedRoutes\n      if (roles.includes('admin')) {\n        accessedRoutes = asyncRoutes || []\n      } else {\n        accessedRoutes = filterAsyncRoutes(asyncRoutes, roles)\n      }\n      commit('SET_ROUTES', accessedRoutes)\n      resolve(accessedRoutes)\n    })\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions\n}\n"]}]}